// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countMessagesInTopic = `-- name: CountMessagesInTopic :one
SELECT COUNT(*) FROM messages
WHERE topic = ?
`

func (q *Queries) CountMessagesInTopic(ctx context.Context, topic string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMessagesInTopic, topic)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPrunableMessages = `-- name: CountPrunableMessages :one
SELECT COUNT(*) FROM messages
WHERE created_at < ?
`

func (q *Queries) CountPrunableMessages(ctx context.Context, createdAt int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPrunableMessages, createdAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOldestMessagesInTopic = `-- name: DeleteOldestMessagesInTopic :exec
DELETE FROM messages
WHERE id IN (
    SELECT id FROM messages AS m
    WHERE m.topic = ?
    ORDER BY m.created_at ASC
    LIMIT ?
)
`

type DeleteOldestMessagesInTopicParams struct {
	Topic string `json:"topic"`
	Limit int64  `json:"limit"`
}

func (q *Queries) DeleteOldestMessagesInTopic(ctx context.Context, arg DeleteOldestMessagesInTopicParams) error {
	_, err := q.db.ExecContext(ctx, deleteOldestMessagesInTopic, arg.Topic, arg.Limit)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, id)
	return err
}

const findRecyclableSession = `-- name: FindRecyclableSession :one
SELECT id, name, slug, path, remote, state, metadata, created_at, updated_at, last_inbox_read FROM sessions
WHERE state = 'recycled' AND remote = ?
ORDER BY updated_at ASC
LIMIT 1
`

func (q *Queries) FindRecyclableSession(ctx context.Context, remote string) (Session, error) {
	row := q.db.QueryRowContext(ctx, findRecyclableSession, remote)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Path,
		&i.Remote,
		&i.State,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastInboxRead,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id, name, slug, path, remote, state, metadata, created_at, updated_at, last_inbox_read FROM sessions
WHERE id = ?
`

func (q *Queries) GetSession(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Path,
		&i.Remote,
		&i.State,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastInboxRead,
	)
	return i, err
}

const listSessions = `-- name: ListSessions :many
SELECT id, name, slug, path, remote, state, metadata, created_at, updated_at, last_inbox_read FROM sessions
ORDER BY created_at DESC
`

func (q *Queries) ListSessions(ctx context.Context) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Path,
			&i.Remote,
			&i.State,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastInboxRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopics = `-- name: ListTopics :many
SELECT name FROM topics
ORDER BY name ASC
`

func (q *Queries) ListTopics(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pruneMessages = `-- name: PruneMessages :exec
DELETE FROM messages
WHERE created_at < ?
`

func (q *Queries) PruneMessages(ctx context.Context, createdAt int64) error {
	_, err := q.db.ExecContext(ctx, pruneMessages, createdAt)
	return err
}

const publishMessage = `-- name: PublishMessage :exec
INSERT INTO messages (
    id, topic, payload, sender, session_id, created_at
) VALUES (?, ?, ?, ?, ?, ?)
`

type PublishMessageParams struct {
	ID        string         `json:"id"`
	Topic     string         `json:"topic"`
	Payload   string         `json:"payload"`
	Sender    sql.NullString `json:"sender"`
	SessionID sql.NullString `json:"session_id"`
	CreatedAt int64          `json:"created_at"`
}

func (q *Queries) PublishMessage(ctx context.Context, arg PublishMessageParams) error {
	_, err := q.db.ExecContext(ctx, publishMessage,
		arg.ID,
		arg.Topic,
		arg.Payload,
		arg.Sender,
		arg.SessionID,
		arg.CreatedAt,
	)
	return err
}

const saveSession = `-- name: SaveSession :exec
INSERT INTO sessions (
    id, name, slug, path, remote, state, metadata,
    created_at, updated_at, last_inbox_read
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    name = excluded.name,
    slug = excluded.slug,
    path = excluded.path,
    remote = excluded.remote,
    state = excluded.state,
    metadata = excluded.metadata,
    updated_at = excluded.updated_at,
    last_inbox_read = excluded.last_inbox_read
`

type SaveSessionParams struct {
	ID            string         `json:"id"`
	Name          string         `json:"name"`
	Slug          string         `json:"slug"`
	Path          string         `json:"path"`
	Remote        string         `json:"remote"`
	State         string         `json:"state"`
	Metadata      sql.NullString `json:"metadata"`
	CreatedAt     int64          `json:"created_at"`
	UpdatedAt     int64          `json:"updated_at"`
	LastInboxRead sql.NullInt64  `json:"last_inbox_read"`
}

func (q *Queries) SaveSession(ctx context.Context, arg SaveSessionParams) error {
	_, err := q.db.ExecContext(ctx, saveSession,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Path,
		arg.Remote,
		arg.State,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.LastInboxRead,
	)
	return err
}

const subscribeToTopic = `-- name: SubscribeToTopic :many
SELECT id, topic, payload, sender, session_id, created_at FROM messages
WHERE topic = ? AND created_at > ?
ORDER BY created_at ASC
`

type SubscribeToTopicParams struct {
	Topic     string `json:"topic"`
	CreatedAt int64  `json:"created_at"`
}

func (q *Queries) SubscribeToTopic(ctx context.Context, arg SubscribeToTopicParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, subscribeToTopic, arg.Topic, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Topic,
			&i.Payload,
			&i.Sender,
			&i.SessionID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
