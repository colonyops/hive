// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const acknowledgeMessages = `-- name: AcknowledgeMessages :exec
INSERT INTO message_reads (message_id, consumer_id, read_at)
VALUES (?, ?, ?)
ON CONFLICT (message_id, consumer_id) DO UPDATE SET
    read_at = excluded.read_at
`

type AcknowledgeMessagesParams struct {
	MessageID  string `json:"message_id"`
	ConsumerID string `json:"consumer_id"`
	ReadAt     int64  `json:"read_at"`
}

func (q *Queries) AcknowledgeMessages(ctx context.Context, arg AcknowledgeMessagesParams) error {
	_, err := q.db.ExecContext(ctx, acknowledgeMessages, arg.MessageID, arg.ConsumerID, arg.ReadAt)
	return err
}

const countCustomTodoItemsBySessionSince = `-- name: CountCustomTodoItemsBySessionSince :one
SELECT COUNT(*) FROM todo_items
WHERE type = 'custom' AND session_id = ? AND created_at >= ?
`

type CountCustomTodoItemsBySessionSinceParams struct {
	SessionID sql.NullString `json:"session_id"`
	CreatedAt int64          `json:"created_at"`
}

func (q *Queries) CountCustomTodoItemsBySessionSince(ctx context.Context, arg CountCustomTodoItemsBySessionSinceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCustomTodoItemsBySessionSince, arg.SessionID, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMessagesInTopic = `-- name: CountMessagesInTopic :one
SELECT COUNT(*) FROM messages
WHERE topic = ?
`

func (q *Queries) CountMessagesInTopic(ctx context.Context, topic string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMessagesInTopic, topic)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNotifications = `-- name: CountNotifications :one
SELECT COUNT(*) FROM notifications
`

func (q *Queries) CountNotifications(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotifications)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingTodoItems = `-- name: CountPendingTodoItems :one
SELECT COUNT(*) FROM todo_items
WHERE status = 'pending'
`

func (q *Queries) CountPendingTodoItems(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingTodoItems)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingTodoItemsBySession = `-- name: CountPendingTodoItemsBySession :one
SELECT COUNT(*) FROM todo_items
WHERE status = 'pending' AND session_id = ?
`

func (q *Queries) CountPendingTodoItemsBySession(ctx context.Context, sessionID sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingTodoItemsBySession, sessionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPrunableMessages = `-- name: CountPrunableMessages :one
SELECT COUNT(*) FROM messages
WHERE created_at < ?
`

func (q *Queries) CountPrunableMessages(ctx context.Context, createdAt int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPrunableMessages, createdAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReviewSession = `-- name: CreateReviewSession :exec
INSERT INTO review_sessions (
    id, document_path, content_hash, created_at, finalized_at
) VALUES (?, ?, ?, ?, ?)
`

type CreateReviewSessionParams struct {
	ID           string        `json:"id"`
	DocumentPath string        `json:"document_path"`
	ContentHash  string        `json:"content_hash"`
	CreatedAt    int64         `json:"created_at"`
	FinalizedAt  sql.NullInt64 `json:"finalized_at"`
}

func (q *Queries) CreateReviewSession(ctx context.Context, arg CreateReviewSessionParams) error {
	_, err := q.db.ExecContext(ctx, createReviewSession,
		arg.ID,
		arg.DocumentPath,
		arg.ContentHash,
		arg.CreatedAt,
		arg.FinalizedAt,
	)
	return err
}

const createTodoItem = `-- name: CreateTodoItem :exec
INSERT INTO todo_items (
    id, type, status, title, description, file_path, session_id, repo_remote,
    created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateTodoItemParams struct {
	ID          string         `json:"id"`
	Type        string         `json:"type"`
	Status      string         `json:"status"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	FilePath    sql.NullString `json:"file_path"`
	SessionID   sql.NullString `json:"session_id"`
	RepoRemote  string         `json:"repo_remote"`
	CreatedAt   int64          `json:"created_at"`
	UpdatedAt   int64          `json:"updated_at"`
}

func (q *Queries) CreateTodoItem(ctx context.Context, arg CreateTodoItemParams) error {
	_, err := q.db.ExecContext(ctx, createTodoItem,
		arg.ID,
		arg.Type,
		arg.Status,
		arg.Title,
		arg.Description,
		arg.FilePath,
		arg.SessionID,
		arg.RepoRemote,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteAllNotifications = `-- name: DeleteAllNotifications :exec
DELETE FROM notifications
`

func (q *Queries) DeleteAllNotifications(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllNotifications)
	return err
}

const deleteOldestMessagesInTopic = `-- name: DeleteOldestMessagesInTopic :exec
DELETE FROM messages
WHERE id IN (
    SELECT id FROM messages AS m
    WHERE m.topic = ?
    ORDER BY m.created_at ASC
    LIMIT ?
)
`

type DeleteOldestMessagesInTopicParams struct {
	Topic string `json:"topic"`
	Limit int64  `json:"limit"`
}

func (q *Queries) DeleteOldestMessagesInTopic(ctx context.Context, arg DeleteOldestMessagesInTopicParams) error {
	_, err := q.db.ExecContext(ctx, deleteOldestMessagesInTopic, arg.Topic, arg.Limit)
	return err
}

const deleteReviewComment = `-- name: DeleteReviewComment :exec
DELETE FROM review_comments
WHERE id = ?
`

func (q *Queries) DeleteReviewComment(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteReviewComment, id)
	return err
}

const deleteReviewSession = `-- name: DeleteReviewSession :exec
DELETE FROM review_sessions
WHERE id = ?
`

func (q *Queries) DeleteReviewSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteReviewSession, id)
	return err
}

const deleteReviewSessionsByDocPath = `-- name: DeleteReviewSessionsByDocPath :exec
DELETE FROM review_sessions
WHERE document_path = ? AND content_hash != ?
`

type DeleteReviewSessionsByDocPathParams struct {
	DocumentPath string `json:"document_path"`
	ContentHash  string `json:"content_hash"`
}

func (q *Queries) DeleteReviewSessionsByDocPath(ctx context.Context, arg DeleteReviewSessionsByDocPathParams) error {
	_, err := q.db.ExecContext(ctx, deleteReviewSessionsByDocPath, arg.DocumentPath, arg.ContentHash)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, id)
	return err
}

const dismissTodoItemsByPath = `-- name: DismissTodoItemsByPath :exec
UPDATE todo_items
SET status = 'dismissed', updated_at = ?
WHERE file_path = ? AND status = 'pending'
`

type DismissTodoItemsByPathParams struct {
	UpdatedAt int64          `json:"updated_at"`
	FilePath  sql.NullString `json:"file_path"`
}

func (q *Queries) DismissTodoItemsByPath(ctx context.Context, arg DismissTodoItemsByPathParams) error {
	_, err := q.db.ExecContext(ctx, dismissTodoItemsByPath, arg.UpdatedAt, arg.FilePath)
	return err
}

const finalizeReviewSession = `-- name: FinalizeReviewSession :exec
UPDATE review_sessions
SET finalized_at = ?
WHERE id = ?
`

type FinalizeReviewSessionParams struct {
	FinalizedAt sql.NullInt64 `json:"finalized_at"`
	ID          string        `json:"id"`
}

func (q *Queries) FinalizeReviewSession(ctx context.Context, arg FinalizeReviewSessionParams) error {
	_, err := q.db.ExecContext(ctx, finalizeReviewSession, arg.FinalizedAt, arg.ID)
	return err
}

const findRecyclableSession = `-- name: FindRecyclableSession :one
SELECT id, name, slug, path, remote, state, metadata, created_at, updated_at FROM sessions
WHERE state = 'recycled' AND remote = ?
ORDER BY updated_at ASC
LIMIT 1
`

func (q *Queries) FindRecyclableSession(ctx context.Context, remote string) (Session, error) {
	row := q.db.QueryRowContext(ctx, findRecyclableSession, remote)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Path,
		&i.Remote,
		&i.State,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllActiveSessionsWithCounts = `-- name: GetAllActiveSessionsWithCounts :many
SELECT
    rs.id,
    rs.document_path,
    rs.content_hash,
    rs.created_at,
    rs.finalized_at,
    COUNT(rc.id) as comment_count
FROM review_sessions rs
LEFT JOIN review_comments rc ON rs.id = rc.session_id
WHERE rs.finalized_at IS NULL
GROUP BY rs.id
`

type GetAllActiveSessionsWithCountsRow struct {
	ID           string        `json:"id"`
	DocumentPath string        `json:"document_path"`
	ContentHash  string        `json:"content_hash"`
	CreatedAt    int64         `json:"created_at"`
	FinalizedAt  sql.NullInt64 `json:"finalized_at"`
	CommentCount int64         `json:"comment_count"`
}

func (q *Queries) GetAllActiveSessionsWithCounts(ctx context.Context) ([]GetAllActiveSessionsWithCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllActiveSessionsWithCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllActiveSessionsWithCountsRow{}
	for rows.Next() {
		var i GetAllActiveSessionsWithCountsRow
		if err := rows.Scan(
			&i.ID,
			&i.DocumentPath,
			&i.ContentHash,
			&i.CreatedAt,
			&i.FinalizedAt,
			&i.CommentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewSessionByDocPath = `-- name: GetReviewSessionByDocPath :one
SELECT id, document_path, content_hash, created_at, finalized_at FROM review_sessions
WHERE document_path = ?
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetReviewSessionByDocPath(ctx context.Context, documentPath string) (ReviewSession, error) {
	row := q.db.QueryRowContext(ctx, getReviewSessionByDocPath, documentPath)
	var i ReviewSession
	err := row.Scan(
		&i.ID,
		&i.DocumentPath,
		&i.ContentHash,
		&i.CreatedAt,
		&i.FinalizedAt,
	)
	return i, err
}

const getReviewSessionByDocPathAndHash = `-- name: GetReviewSessionByDocPathAndHash :one
SELECT id, document_path, content_hash, created_at, finalized_at FROM review_sessions
WHERE document_path = ? AND content_hash = ?
`

type GetReviewSessionByDocPathAndHashParams struct {
	DocumentPath string `json:"document_path"`
	ContentHash  string `json:"content_hash"`
}

func (q *Queries) GetReviewSessionByDocPathAndHash(ctx context.Context, arg GetReviewSessionByDocPathAndHashParams) (ReviewSession, error) {
	row := q.db.QueryRowContext(ctx, getReviewSessionByDocPathAndHash, arg.DocumentPath, arg.ContentHash)
	var i ReviewSession
	err := row.Scan(
		&i.ID,
		&i.DocumentPath,
		&i.ContentHash,
		&i.CreatedAt,
		&i.FinalizedAt,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id, name, slug, path, remote, state, metadata, created_at, updated_at FROM sessions
WHERE id = ?
`

func (q *Queries) GetSession(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Path,
		&i.Remote,
		&i.State,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTodoItem = `-- name: GetTodoItem :one
SELECT id, type, status, title, description, file_path, session_id, repo_remote, created_at, updated_at FROM todo_items
WHERE id = ?
`

func (q *Queries) GetTodoItem(ctx context.Context, id string) (TodoItem, error) {
	row := q.db.QueryRowContext(ctx, getTodoItem, id)
	var i TodoItem
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.Title,
		&i.Description,
		&i.FilePath,
		&i.SessionID,
		&i.RepoRemote,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUnreadMessages = `-- name: GetUnreadMessages :many
SELECT m.id, m.topic, m.payload, m.sender, m.session_id, m.created_at
FROM messages m
LEFT JOIN message_reads mr ON mr.message_id = m.id AND mr.consumer_id = ?
WHERE m.topic = ?
  AND mr.message_id IS NULL
ORDER BY m.created_at ASC
`

type GetUnreadMessagesParams struct {
	ConsumerID string `json:"consumer_id"`
	Topic      string `json:"topic"`
}

func (q *Queries) GetUnreadMessages(ctx context.Context, arg GetUnreadMessagesParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getUnreadMessages, arg.ConsumerID, arg.Topic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Topic,
			&i.Payload,
			&i.Sender,
			&i.SessionID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertNotification = `-- name: InsertNotification :one
INSERT INTO notifications (level, message, created_at)
VALUES (?, ?, ?)
RETURNING id
`

type InsertNotificationParams struct {
	Level     string `json:"level"`
	Message   string `json:"message"`
	CreatedAt int64  `json:"created_at"`
}

func (q *Queries) InsertNotification(ctx context.Context, arg InsertNotificationParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertNotification, arg.Level, arg.Message, arg.CreatedAt)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const kVDelete = `-- name: KVDelete :exec
DELETE FROM kv_store WHERE key = ?
`

func (q *Queries) KVDelete(ctx context.Context, key string) error {
	_, err := q.db.ExecContext(ctx, kVDelete, key)
	return err
}

const kVGet = `-- name: KVGet :one
SELECT "key", value, expires_at, created_at, updated_at FROM kv_store WHERE key = ?
`

func (q *Queries) KVGet(ctx context.Context, key string) (KvStore, error) {
	row := q.db.QueryRowContext(ctx, kVGet, key)
	var i KvStore
	err := row.Scan(
		&i.Key,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const kVGetRaw = `-- name: KVGetRaw :one
SELECT key, value, expires_at, created_at, updated_at FROM kv_store WHERE key = ?
`

func (q *Queries) KVGetRaw(ctx context.Context, key string) (KvStore, error) {
	row := q.db.QueryRowContext(ctx, kVGetRaw, key)
	var i KvStore
	err := row.Scan(
		&i.Key,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const kVHas = `-- name: KVHas :one
SELECT COUNT(*) FROM kv_store WHERE key = ?
`

func (q *Queries) KVHas(ctx context.Context, key string) (int64, error) {
	row := q.db.QueryRowContext(ctx, kVHas, key)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const kVListKeys = `-- name: KVListKeys :many
SELECT key FROM kv_store
WHERE expires_at IS NULL OR expires_at >= ?
ORDER BY key ASC
`

func (q *Queries) KVListKeys(ctx context.Context, expiresAt sql.NullInt64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, kVListKeys, expiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const kVSet = `-- name: KVSet :exec
INSERT INTO kv_store (key, value, expires_at, created_at, updated_at)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(key) DO UPDATE SET
    value = excluded.value,
    expires_at = excluded.expires_at,
    updated_at = excluded.updated_at
`

type KVSetParams struct {
	Key       string        `json:"key"`
	Value     []byte        `json:"value"`
	ExpiresAt sql.NullInt64 `json:"expires_at"`
	CreatedAt int64         `json:"created_at"`
	UpdatedAt int64         `json:"updated_at"`
}

func (q *Queries) KVSet(ctx context.Context, arg KVSetParams) error {
	_, err := q.db.ExecContext(ctx, kVSet,
		arg.Key,
		arg.Value,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const kVSweepExpired = `-- name: KVSweepExpired :exec
DELETE FROM kv_store WHERE expires_at IS NOT NULL AND expires_at < ?
`

func (q *Queries) KVSweepExpired(ctx context.Context, expiresAt sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, kVSweepExpired, expiresAt)
	return err
}

const listNotifications = `-- name: ListNotifications :many
SELECT id, level, message, created_at FROM notifications
ORDER BY created_at DESC
`

func (q *Queries) ListNotifications(ctx context.Context) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, listNotifications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Message,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReviewComments = `-- name: ListReviewComments :many
SELECT id, session_id, start_line, end_line, context_text, comment_text, created_at FROM review_comments
WHERE session_id = ?
ORDER BY start_line ASC
`

func (q *Queries) ListReviewComments(ctx context.Context, sessionID string) ([]ReviewComment, error) {
	rows, err := q.db.QueryContext(ctx, listReviewComments, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReviewComment{}
	for rows.Next() {
		var i ReviewComment
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.StartLine,
			&i.EndLine,
			&i.ContextText,
			&i.CommentText,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessions = `-- name: ListSessions :many
SELECT id, name, slug, path, remote, state, metadata, created_at, updated_at FROM sessions
ORDER BY created_at DESC
`

func (q *Queries) ListSessions(ctx context.Context) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Path,
			&i.Remote,
			&i.State,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodoItems = `-- name: ListTodoItems :many
SELECT id, type, status, title, description, file_path, session_id, repo_remote, created_at, updated_at FROM todo_items
ORDER BY created_at DESC
`

func (q *Queries) ListTodoItems(ctx context.Context) ([]TodoItem, error) {
	rows, err := q.db.QueryContext(ctx, listTodoItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.Title,
			&i.Description,
			&i.FilePath,
			&i.SessionID,
			&i.RepoRemote,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodoItemsByRepo = `-- name: ListTodoItemsByRepo :many
SELECT id, type, status, title, description, file_path, session_id, repo_remote, created_at, updated_at FROM todo_items
WHERE repo_remote = ?
ORDER BY created_at DESC
`

func (q *Queries) ListTodoItemsByRepo(ctx context.Context, repoRemote string) ([]TodoItem, error) {
	rows, err := q.db.QueryContext(ctx, listTodoItemsByRepo, repoRemote)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.Title,
			&i.Description,
			&i.FilePath,
			&i.SessionID,
			&i.RepoRemote,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodoItemsBySession = `-- name: ListTodoItemsBySession :many
SELECT id, type, status, title, description, file_path, session_id, repo_remote, created_at, updated_at FROM todo_items
WHERE session_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListTodoItemsBySession(ctx context.Context, sessionID sql.NullString) ([]TodoItem, error) {
	rows, err := q.db.QueryContext(ctx, listTodoItemsBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.Title,
			&i.Description,
			&i.FilePath,
			&i.SessionID,
			&i.RepoRemote,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodoItemsByStatus = `-- name: ListTodoItemsByStatus :many
SELECT id, type, status, title, description, file_path, session_id, repo_remote, created_at, updated_at FROM todo_items
WHERE status = ?
ORDER BY created_at DESC
`

func (q *Queries) ListTodoItemsByStatus(ctx context.Context, status string) ([]TodoItem, error) {
	rows, err := q.db.QueryContext(ctx, listTodoItemsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.Title,
			&i.Description,
			&i.FilePath,
			&i.SessionID,
			&i.RepoRemote,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodoItemsByStatusAndRepo = `-- name: ListTodoItemsByStatusAndRepo :many
SELECT id, type, status, title, description, file_path, session_id, repo_remote, created_at, updated_at FROM todo_items
WHERE status = ? AND repo_remote = ?
ORDER BY created_at DESC
`

type ListTodoItemsByStatusAndRepoParams struct {
	Status     string `json:"status"`
	RepoRemote string `json:"repo_remote"`
}

func (q *Queries) ListTodoItemsByStatusAndRepo(ctx context.Context, arg ListTodoItemsByStatusAndRepoParams) ([]TodoItem, error) {
	rows, err := q.db.QueryContext(ctx, listTodoItemsByStatusAndRepo, arg.Status, arg.RepoRemote)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.Title,
			&i.Description,
			&i.FilePath,
			&i.SessionID,
			&i.RepoRemote,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodoItemsByStatusAndSession = `-- name: ListTodoItemsByStatusAndSession :many
SELECT id, type, status, title, description, file_path, session_id, repo_remote, created_at, updated_at FROM todo_items
WHERE status = ? AND session_id = ?
ORDER BY created_at DESC
`

type ListTodoItemsByStatusAndSessionParams struct {
	Status    string         `json:"status"`
	SessionID sql.NullString `json:"session_id"`
}

func (q *Queries) ListTodoItemsByStatusAndSession(ctx context.Context, arg ListTodoItemsByStatusAndSessionParams) ([]TodoItem, error) {
	rows, err := q.db.QueryContext(ctx, listTodoItemsByStatusAndSession, arg.Status, arg.SessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.Title,
			&i.Description,
			&i.FilePath,
			&i.SessionID,
			&i.RepoRemote,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopics = `-- name: ListTopics :many
SELECT name FROM topics
ORDER BY name ASC
`

func (q *Queries) ListTopics(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pruneMessages = `-- name: PruneMessages :exec
DELETE FROM messages
WHERE created_at < ?
`

func (q *Queries) PruneMessages(ctx context.Context, createdAt int64) error {
	_, err := q.db.ExecContext(ctx, pruneMessages, createdAt)
	return err
}

const publishMessage = `-- name: PublishMessage :exec
INSERT INTO messages (
    id, topic, payload, sender, session_id, created_at
) VALUES (?, ?, ?, ?, ?, ?)
`

type PublishMessageParams struct {
	ID        string         `json:"id"`
	Topic     string         `json:"topic"`
	Payload   string         `json:"payload"`
	Sender    sql.NullString `json:"sender"`
	SessionID sql.NullString `json:"session_id"`
	CreatedAt int64          `json:"created_at"`
}

func (q *Queries) PublishMessage(ctx context.Context, arg PublishMessageParams) error {
	_, err := q.db.ExecContext(ctx, publishMessage,
		arg.ID,
		arg.Topic,
		arg.Payload,
		arg.Sender,
		arg.SessionID,
		arg.CreatedAt,
	)
	return err
}

const saveReviewComment = `-- name: SaveReviewComment :exec
INSERT INTO review_comments (
    id, session_id, start_line, end_line, context_text, comment_text, created_at
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type SaveReviewCommentParams struct {
	ID          string `json:"id"`
	SessionID   string `json:"session_id"`
	StartLine   int64  `json:"start_line"`
	EndLine     int64  `json:"end_line"`
	ContextText string `json:"context_text"`
	CommentText string `json:"comment_text"`
	CreatedAt   int64  `json:"created_at"`
}

func (q *Queries) SaveReviewComment(ctx context.Context, arg SaveReviewCommentParams) error {
	_, err := q.db.ExecContext(ctx, saveReviewComment,
		arg.ID,
		arg.SessionID,
		arg.StartLine,
		arg.EndLine,
		arg.ContextText,
		arg.CommentText,
		arg.CreatedAt,
	)
	return err
}

const saveSession = `-- name: SaveSession :exec
INSERT INTO sessions (
    id, name, slug, path, remote, state, metadata,
    created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    name = excluded.name,
    slug = excluded.slug,
    path = excluded.path,
    remote = excluded.remote,
    state = excluded.state,
    metadata = excluded.metadata,
    updated_at = excluded.updated_at
`

type SaveSessionParams struct {
	ID        string         `json:"id"`
	Name      string         `json:"name"`
	Slug      string         `json:"slug"`
	Path      string         `json:"path"`
	Remote    string         `json:"remote"`
	State     string         `json:"state"`
	Metadata  sql.NullString `json:"metadata"`
	CreatedAt int64          `json:"created_at"`
	UpdatedAt int64          `json:"updated_at"`
}

func (q *Queries) SaveSession(ctx context.Context, arg SaveSessionParams) error {
	_, err := q.db.ExecContext(ctx, saveSession,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Path,
		arg.Remote,
		arg.State,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const subscribeToTopic = `-- name: SubscribeToTopic :many
SELECT id, topic, payload, sender, session_id, created_at FROM messages
WHERE topic = ? AND created_at > ?
ORDER BY created_at ASC
`

type SubscribeToTopicParams struct {
	Topic     string `json:"topic"`
	CreatedAt int64  `json:"created_at"`
}

func (q *Queries) SubscribeToTopic(ctx context.Context, arg SubscribeToTopicParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, subscribeToTopic, arg.Topic, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Topic,
			&i.Payload,
			&i.Sender,
			&i.SessionID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReviewComment = `-- name: UpdateReviewComment :exec
UPDATE review_comments
SET comment_text = ?
WHERE id = ?
`

type UpdateReviewCommentParams struct {
	CommentText string `json:"comment_text"`
	ID          string `json:"id"`
}

func (q *Queries) UpdateReviewComment(ctx context.Context, arg UpdateReviewCommentParams) error {
	_, err := q.db.ExecContext(ctx, updateReviewComment, arg.CommentText, arg.ID)
	return err
}

const updateTodoItemStatus = `-- name: UpdateTodoItemStatus :exec
UPDATE todo_items
SET status = ?, updated_at = ?
WHERE id = ?
`

type UpdateTodoItemStatusParams struct {
	Status    string `json:"status"`
	UpdatedAt int64  `json:"updated_at"`
	ID        string `json:"id"`
}

func (q *Queries) UpdateTodoItemStatus(ctx context.Context, arg UpdateTodoItemStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTodoItemStatus, arg.Status, arg.UpdatedAt, arg.ID)
	return err
}
