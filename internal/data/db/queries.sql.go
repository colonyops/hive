// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const acknowledgeMessages = `-- name: AcknowledgeMessages :exec
INSERT INTO message_reads (message_id, consumer_id, read_at)
VALUES (?, ?, ?)
ON CONFLICT (message_id, consumer_id) DO UPDATE SET
    read_at = excluded.read_at
`

type AcknowledgeMessagesParams struct {
	MessageID  string `json:"message_id"`
	ConsumerID string `json:"consumer_id"`
	ReadAt     int64  `json:"read_at"`
}

func (q *Queries) AcknowledgeMessages(ctx context.Context, arg AcknowledgeMessagesParams) error {
	_, err := q.db.ExecContext(ctx, acknowledgeMessages, arg.MessageID, arg.ConsumerID, arg.ReadAt)
	return err
}

const countMessagesInTopic = `-- name: CountMessagesInTopic :one
SELECT COUNT(*) FROM messages
WHERE topic = ?
`

func (q *Queries) CountMessagesInTopic(ctx context.Context, topic string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMessagesInTopic, topic)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPrunableMessages = `-- name: CountPrunableMessages :one
SELECT COUNT(*) FROM messages
WHERE created_at < ?
`

func (q *Queries) CountPrunableMessages(ctx context.Context, createdAt int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPrunableMessages, createdAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReviewSession = `-- name: CreateReviewSession :exec
INSERT INTO review_sessions (
    id, document_path, content_hash, created_at, finalized_at
) VALUES (?, ?, ?, ?, ?)
`

type CreateReviewSessionParams struct {
	ID           string        `json:"id"`
	DocumentPath string        `json:"document_path"`
	ContentHash  string        `json:"content_hash"`
	CreatedAt    int64         `json:"created_at"`
	FinalizedAt  sql.NullInt64 `json:"finalized_at"`
}

func (q *Queries) CreateReviewSession(ctx context.Context, arg CreateReviewSessionParams) error {
	_, err := q.db.ExecContext(ctx, createReviewSession,
		arg.ID,
		arg.DocumentPath,
		arg.ContentHash,
		arg.CreatedAt,
		arg.FinalizedAt,
	)
	return err
}

const deleteOldestMessagesInTopic = `-- name: DeleteOldestMessagesInTopic :exec
DELETE FROM messages
WHERE id IN (
    SELECT id FROM messages AS m
    WHERE m.topic = ?
    ORDER BY m.created_at ASC
    LIMIT ?
)
`

type DeleteOldestMessagesInTopicParams struct {
	Topic string `json:"topic"`
	Limit int64  `json:"limit"`
}

func (q *Queries) DeleteOldestMessagesInTopic(ctx context.Context, arg DeleteOldestMessagesInTopicParams) error {
	_, err := q.db.ExecContext(ctx, deleteOldestMessagesInTopic, arg.Topic, arg.Limit)
	return err
}

const deleteReviewComment = `-- name: DeleteReviewComment :exec
DELETE FROM review_comments
WHERE id = ?
`

func (q *Queries) DeleteReviewComment(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteReviewComment, id)
	return err
}

const deleteReviewSession = `-- name: DeleteReviewSession :exec
DELETE FROM review_sessions
WHERE id = ?
`

func (q *Queries) DeleteReviewSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteReviewSession, id)
	return err
}

const deleteReviewSessionsByDocPath = `-- name: DeleteReviewSessionsByDocPath :exec
DELETE FROM review_sessions
WHERE document_path = ? AND content_hash != ?
`

type DeleteReviewSessionsByDocPathParams struct {
	DocumentPath string `json:"document_path"`
	ContentHash  string `json:"content_hash"`
}

func (q *Queries) DeleteReviewSessionsByDocPath(ctx context.Context, arg DeleteReviewSessionsByDocPathParams) error {
	_, err := q.db.ExecContext(ctx, deleteReviewSessionsByDocPath, arg.DocumentPath, arg.ContentHash)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, id)
	return err
}

const finalizeReviewSession = `-- name: FinalizeReviewSession :exec
UPDATE review_sessions
SET finalized_at = ?
WHERE id = ?
`

type FinalizeReviewSessionParams struct {
	FinalizedAt sql.NullInt64 `json:"finalized_at"`
	ID          string        `json:"id"`
}

func (q *Queries) FinalizeReviewSession(ctx context.Context, arg FinalizeReviewSessionParams) error {
	_, err := q.db.ExecContext(ctx, finalizeReviewSession, arg.FinalizedAt, arg.ID)
	return err
}

const findRecyclableSession = `-- name: FindRecyclableSession :one
SELECT id, name, slug, path, remote, state, metadata, created_at, updated_at FROM sessions
WHERE state = 'recycled' AND remote = ?
ORDER BY updated_at ASC
LIMIT 1
`

func (q *Queries) FindRecyclableSession(ctx context.Context, remote string) (Session, error) {
	row := q.db.QueryRowContext(ctx, findRecyclableSession, remote)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Path,
		&i.Remote,
		&i.State,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllActiveSessionsWithCounts = `-- name: GetAllActiveSessionsWithCounts :many
SELECT
    rs.id,
    rs.document_path,
    rs.content_hash,
    rs.created_at,
    rs.finalized_at,
    COUNT(rc.id) as comment_count
FROM review_sessions rs
LEFT JOIN review_comments rc ON rs.id = rc.session_id
WHERE rs.finalized_at IS NULL
GROUP BY rs.id
`

type GetAllActiveSessionsWithCountsRow struct {
	ID           string        `json:"id"`
	DocumentPath string        `json:"document_path"`
	ContentHash  string        `json:"content_hash"`
	CreatedAt    int64         `json:"created_at"`
	FinalizedAt  sql.NullInt64 `json:"finalized_at"`
	CommentCount int64         `json:"comment_count"`
}

func (q *Queries) GetAllActiveSessionsWithCounts(ctx context.Context) ([]GetAllActiveSessionsWithCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllActiveSessionsWithCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllActiveSessionsWithCountsRow{}
	for rows.Next() {
		var i GetAllActiveSessionsWithCountsRow
		if err := rows.Scan(
			&i.ID,
			&i.DocumentPath,
			&i.ContentHash,
			&i.CreatedAt,
			&i.FinalizedAt,
			&i.CommentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewSessionByDocPath = `-- name: GetReviewSessionByDocPath :one
SELECT id, document_path, content_hash, created_at, finalized_at FROM review_sessions
WHERE document_path = ?
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetReviewSessionByDocPath(ctx context.Context, documentPath string) (ReviewSession, error) {
	row := q.db.QueryRowContext(ctx, getReviewSessionByDocPath, documentPath)
	var i ReviewSession
	err := row.Scan(
		&i.ID,
		&i.DocumentPath,
		&i.ContentHash,
		&i.CreatedAt,
		&i.FinalizedAt,
	)
	return i, err
}

const getReviewSessionByDocPathAndHash = `-- name: GetReviewSessionByDocPathAndHash :one
SELECT id, document_path, content_hash, created_at, finalized_at FROM review_sessions
WHERE document_path = ? AND content_hash = ?
`

type GetReviewSessionByDocPathAndHashParams struct {
	DocumentPath string `json:"document_path"`
	ContentHash  string `json:"content_hash"`
}

func (q *Queries) GetReviewSessionByDocPathAndHash(ctx context.Context, arg GetReviewSessionByDocPathAndHashParams) (ReviewSession, error) {
	row := q.db.QueryRowContext(ctx, getReviewSessionByDocPathAndHash, arg.DocumentPath, arg.ContentHash)
	var i ReviewSession
	err := row.Scan(
		&i.ID,
		&i.DocumentPath,
		&i.ContentHash,
		&i.CreatedAt,
		&i.FinalizedAt,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id, name, slug, path, remote, state, metadata, created_at, updated_at FROM sessions
WHERE id = ?
`

func (q *Queries) GetSession(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Path,
		&i.Remote,
		&i.State,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUnreadMessages = `-- name: GetUnreadMessages :many
SELECT m.id, m.topic, m.payload, m.sender, m.session_id, m.created_at
FROM messages m
LEFT JOIN message_reads mr ON mr.message_id = m.id AND mr.consumer_id = ?
WHERE m.topic = ?
  AND mr.message_id IS NULL
ORDER BY m.created_at ASC
`

type GetUnreadMessagesParams struct {
	ConsumerID string `json:"consumer_id"`
	Topic      string `json:"topic"`
}

func (q *Queries) GetUnreadMessages(ctx context.Context, arg GetUnreadMessagesParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getUnreadMessages, arg.ConsumerID, arg.Topic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Topic,
			&i.Payload,
			&i.Sender,
			&i.SessionID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReviewComments = `-- name: ListReviewComments :many
SELECT id, session_id, start_line, end_line, context_text, comment_text, created_at FROM review_comments
WHERE session_id = ?
ORDER BY start_line ASC
`

func (q *Queries) ListReviewComments(ctx context.Context, sessionID string) ([]ReviewComment, error) {
	rows, err := q.db.QueryContext(ctx, listReviewComments, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReviewComment{}
	for rows.Next() {
		var i ReviewComment
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.StartLine,
			&i.EndLine,
			&i.ContextText,
			&i.CommentText,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessions = `-- name: ListSessions :many
SELECT id, name, slug, path, remote, state, metadata, created_at, updated_at FROM sessions
ORDER BY created_at DESC
`

func (q *Queries) ListSessions(ctx context.Context) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Path,
			&i.Remote,
			&i.State,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopics = `-- name: ListTopics :many
SELECT name FROM topics
ORDER BY name ASC
`

func (q *Queries) ListTopics(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pruneMessages = `-- name: PruneMessages :exec
DELETE FROM messages
WHERE created_at < ?
`

func (q *Queries) PruneMessages(ctx context.Context, createdAt int64) error {
	_, err := q.db.ExecContext(ctx, pruneMessages, createdAt)
	return err
}

const publishMessage = `-- name: PublishMessage :exec
INSERT INTO messages (
    id, topic, payload, sender, session_id, created_at
) VALUES (?, ?, ?, ?, ?, ?)
`

type PublishMessageParams struct {
	ID        string         `json:"id"`
	Topic     string         `json:"topic"`
	Payload   string         `json:"payload"`
	Sender    sql.NullString `json:"sender"`
	SessionID sql.NullString `json:"session_id"`
	CreatedAt int64          `json:"created_at"`
}

func (q *Queries) PublishMessage(ctx context.Context, arg PublishMessageParams) error {
	_, err := q.db.ExecContext(ctx, publishMessage,
		arg.ID,
		arg.Topic,
		arg.Payload,
		arg.Sender,
		arg.SessionID,
		arg.CreatedAt,
	)
	return err
}

const saveReviewComment = `-- name: SaveReviewComment :exec
INSERT INTO review_comments (
    id, session_id, start_line, end_line, context_text, comment_text, created_at
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type SaveReviewCommentParams struct {
	ID          string `json:"id"`
	SessionID   string `json:"session_id"`
	StartLine   int64  `json:"start_line"`
	EndLine     int64  `json:"end_line"`
	ContextText string `json:"context_text"`
	CommentText string `json:"comment_text"`
	CreatedAt   int64  `json:"created_at"`
}

func (q *Queries) SaveReviewComment(ctx context.Context, arg SaveReviewCommentParams) error {
	_, err := q.db.ExecContext(ctx, saveReviewComment,
		arg.ID,
		arg.SessionID,
		arg.StartLine,
		arg.EndLine,
		arg.ContextText,
		arg.CommentText,
		arg.CreatedAt,
	)
	return err
}

const saveSession = `-- name: SaveSession :exec
INSERT INTO sessions (
    id, name, slug, path, remote, state, metadata,
    created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    name = excluded.name,
    slug = excluded.slug,
    path = excluded.path,
    remote = excluded.remote,
    state = excluded.state,
    metadata = excluded.metadata,
    updated_at = excluded.updated_at
`

type SaveSessionParams struct {
	ID        string         `json:"id"`
	Name      string         `json:"name"`
	Slug      string         `json:"slug"`
	Path      string         `json:"path"`
	Remote    string         `json:"remote"`
	State     string         `json:"state"`
	Metadata  sql.NullString `json:"metadata"`
	CreatedAt int64          `json:"created_at"`
	UpdatedAt int64          `json:"updated_at"`
}

func (q *Queries) SaveSession(ctx context.Context, arg SaveSessionParams) error {
	_, err := q.db.ExecContext(ctx, saveSession,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Path,
		arg.Remote,
		arg.State,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const subscribeToTopic = `-- name: SubscribeToTopic :many
SELECT id, topic, payload, sender, session_id, created_at FROM messages
WHERE topic = ? AND created_at > ?
ORDER BY created_at ASC
`

type SubscribeToTopicParams struct {
	Topic     string `json:"topic"`
	CreatedAt int64  `json:"created_at"`
}

func (q *Queries) SubscribeToTopic(ctx context.Context, arg SubscribeToTopicParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, subscribeToTopic, arg.Topic, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Topic,
			&i.Payload,
			&i.Sender,
			&i.SessionID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReviewComment = `-- name: UpdateReviewComment :exec
UPDATE review_comments
SET comment_text = ?
WHERE id = ?
`

type UpdateReviewCommentParams struct {
	CommentText string `json:"comment_text"`
	ID          string `json:"id"`
}

func (q *Queries) UpdateReviewComment(ctx context.Context, arg UpdateReviewCommentParams) error {
	_, err := q.db.ExecContext(ctx, updateReviewComment, arg.CommentText, arg.ID)
	return err
}
