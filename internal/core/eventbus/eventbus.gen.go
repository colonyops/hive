// Code generated by gobusgen; DO NOT EDIT.
package eventbus

import (
	"context"
	"sync"
)

// Event represents a typed event name.
type Event string

const (
	EventAgentStatusChanged Event = "agent.status-changed"
	EventConfigReloaded     Event = "config.reloaded"
	EventMessageReceived    Event = "message.received"
	EventSessionCorrupted   Event = "session.corrupted"
	EventSessionCreated     Event = "session.created"
	EventSessionDeleted     Event = "session.deleted"
	EventSessionRecycled    Event = "session.recycled"
	EventSessionRenamed     Event = "session.renamed"
	EventTodoCreated        Event = "todo.created"
	EventTodoDismissed      Event = "todo.dismissed"
	EventTuiStarted         Event = "tui.started"
	EventTuiStopped         Event = "tui.stopped"
)

// EventBus provides type-safe publish/subscribe for in-process events.
type EventBus struct {
	mu          sync.RWMutex
	subscribers map[Event][]any
	ch          chan envelope

	hookMu      sync.RWMutex
	onPublish   []func(Event, any)
	onDrop      []func(Event, any)
	onSubscribe []func(Event)
	onPanic     []func(Event, any, any)
}

type envelope struct {
	event   Event
	payload any
}

// New creates an EventBus with the given channel buffer size.
func New(size int) *EventBus {
	if size < 1 {
		size = 1
	}

	return &EventBus{
		subscribers: newSubscribersMap(),
		ch:          make(chan envelope, size),
	}
}

func newSubscribersMap() map[Event][]any {
	return map[Event][]any{
		EventAgentStatusChanged: {},
		EventConfigReloaded:     {},
		EventMessageReceived:    {},
		EventSessionCorrupted:   {},
		EventSessionCreated:     {},
		EventSessionDeleted:     {},
		EventSessionRecycled:    {},
		EventSessionRenamed:     {},
		EventTodoCreated:        {},
		EventTodoDismissed:      {},
		EventTuiStarted:         {},
		EventTuiStopped:         {},
	}
}

// Start begins processing events. It blocks until ctx is cancelled.
func (bus *EventBus) Start(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case env := <-bus.ch:
			bus.mu.RLock()
			subs := make([]any, len(bus.subscribers[env.event]))
			copy(subs, bus.subscribers[env.event])
			bus.mu.RUnlock()

			for _, sub := range subs {
				func() {
					defer func() {
						if r := recover(); r != nil {
							bus.runOnPanic(env.event, env.payload, r)
						}
					}()
					if fn, ok := sub.(func(any)); ok {
						fn(env.payload)
					}
				}()
			}
		}
	}
}

// PublishAgentStatusChanged publishes a agent.status-changed event.
func (bus *EventBus) PublishAgentStatusChanged(payload AgentStatusChangedPayload) {
	select {
	case bus.ch <- envelope{event: EventAgentStatusChanged, payload: payload}:
		bus.runOnPublish(EventAgentStatusChanged, payload)
	default:
		bus.runOnDrop(EventAgentStatusChanged, payload)
	}
}

// SubscribeAgentStatusChanged registers a handler for agent.status-changed events.
func (bus *EventBus) SubscribeAgentStatusChanged(fn func(AgentStatusChangedPayload)) {
	bus.mu.Lock()
	bus.subscribers[EventAgentStatusChanged] = append(bus.subscribers[EventAgentStatusChanged], func(v any) {
		payload, ok := v.(AgentStatusChangedPayload)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventAgentStatusChanged)
}

// PublishConfigReloaded publishes a config.reloaded event.
func (bus *EventBus) PublishConfigReloaded(payload ConfigReloadedPayload) {
	select {
	case bus.ch <- envelope{event: EventConfigReloaded, payload: payload}:
		bus.runOnPublish(EventConfigReloaded, payload)
	default:
		bus.runOnDrop(EventConfigReloaded, payload)
	}
}

// SubscribeConfigReloaded registers a handler for config.reloaded events.
func (bus *EventBus) SubscribeConfigReloaded(fn func(ConfigReloadedPayload)) {
	bus.mu.Lock()
	bus.subscribers[EventConfigReloaded] = append(bus.subscribers[EventConfigReloaded], func(v any) {
		payload, ok := v.(ConfigReloadedPayload)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventConfigReloaded)
}

// PublishMessageReceived publishes a message.received event.
func (bus *EventBus) PublishMessageReceived(payload MessageReceivedPayload) {
	select {
	case bus.ch <- envelope{event: EventMessageReceived, payload: payload}:
		bus.runOnPublish(EventMessageReceived, payload)
	default:
		bus.runOnDrop(EventMessageReceived, payload)
	}
}

// SubscribeMessageReceived registers a handler for message.received events.
func (bus *EventBus) SubscribeMessageReceived(fn func(MessageReceivedPayload)) {
	bus.mu.Lock()
	bus.subscribers[EventMessageReceived] = append(bus.subscribers[EventMessageReceived], func(v any) {
		payload, ok := v.(MessageReceivedPayload)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventMessageReceived)
}

// PublishSessionCorrupted publishes a session.corrupted event.
func (bus *EventBus) PublishSessionCorrupted(payload SessionCorruptedPayload) {
	select {
	case bus.ch <- envelope{event: EventSessionCorrupted, payload: payload}:
		bus.runOnPublish(EventSessionCorrupted, payload)
	default:
		bus.runOnDrop(EventSessionCorrupted, payload)
	}
}

// SubscribeSessionCorrupted registers a handler for session.corrupted events.
func (bus *EventBus) SubscribeSessionCorrupted(fn func(SessionCorruptedPayload)) {
	bus.mu.Lock()
	bus.subscribers[EventSessionCorrupted] = append(bus.subscribers[EventSessionCorrupted], func(v any) {
		payload, ok := v.(SessionCorruptedPayload)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventSessionCorrupted)
}

// PublishSessionCreated publishes a session.created event.
func (bus *EventBus) PublishSessionCreated(payload SessionCreatedPayload) {
	select {
	case bus.ch <- envelope{event: EventSessionCreated, payload: payload}:
		bus.runOnPublish(EventSessionCreated, payload)
	default:
		bus.runOnDrop(EventSessionCreated, payload)
	}
}

// SubscribeSessionCreated registers a handler for session.created events.
func (bus *EventBus) SubscribeSessionCreated(fn func(SessionCreatedPayload)) {
	bus.mu.Lock()
	bus.subscribers[EventSessionCreated] = append(bus.subscribers[EventSessionCreated], func(v any) {
		payload, ok := v.(SessionCreatedPayload)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventSessionCreated)
}

// PublishSessionDeleted publishes a session.deleted event.
func (bus *EventBus) PublishSessionDeleted(payload SessionDeletedPayload) {
	select {
	case bus.ch <- envelope{event: EventSessionDeleted, payload: payload}:
		bus.runOnPublish(EventSessionDeleted, payload)
	default:
		bus.runOnDrop(EventSessionDeleted, payload)
	}
}

// SubscribeSessionDeleted registers a handler for session.deleted events.
func (bus *EventBus) SubscribeSessionDeleted(fn func(SessionDeletedPayload)) {
	bus.mu.Lock()
	bus.subscribers[EventSessionDeleted] = append(bus.subscribers[EventSessionDeleted], func(v any) {
		payload, ok := v.(SessionDeletedPayload)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventSessionDeleted)
}

// PublishSessionRecycled publishes a session.recycled event.
func (bus *EventBus) PublishSessionRecycled(payload SessionRecycledPayload) {
	select {
	case bus.ch <- envelope{event: EventSessionRecycled, payload: payload}:
		bus.runOnPublish(EventSessionRecycled, payload)
	default:
		bus.runOnDrop(EventSessionRecycled, payload)
	}
}

// SubscribeSessionRecycled registers a handler for session.recycled events.
func (bus *EventBus) SubscribeSessionRecycled(fn func(SessionRecycledPayload)) {
	bus.mu.Lock()
	bus.subscribers[EventSessionRecycled] = append(bus.subscribers[EventSessionRecycled], func(v any) {
		payload, ok := v.(SessionRecycledPayload)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventSessionRecycled)
}

// PublishSessionRenamed publishes a session.renamed event.
func (bus *EventBus) PublishSessionRenamed(payload SessionRenamedPayload) {
	select {
	case bus.ch <- envelope{event: EventSessionRenamed, payload: payload}:
		bus.runOnPublish(EventSessionRenamed, payload)
	default:
		bus.runOnDrop(EventSessionRenamed, payload)
	}
}

// SubscribeSessionRenamed registers a handler for session.renamed events.
func (bus *EventBus) SubscribeSessionRenamed(fn func(SessionRenamedPayload)) {
	bus.mu.Lock()
	bus.subscribers[EventSessionRenamed] = append(bus.subscribers[EventSessionRenamed], func(v any) {
		payload, ok := v.(SessionRenamedPayload)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventSessionRenamed)
}

// PublishTodoCreated publishes a todo.created event.
func (bus *EventBus) PublishTodoCreated(payload TodoCreatedPayload) {
	select {
	case bus.ch <- envelope{event: EventTodoCreated, payload: payload}:
		bus.runOnPublish(EventTodoCreated, payload)
	default:
		bus.runOnDrop(EventTodoCreated, payload)
	}
}

// SubscribeTodoCreated registers a handler for todo.created events.
func (bus *EventBus) SubscribeTodoCreated(fn func(TodoCreatedPayload)) {
	bus.mu.Lock()
	bus.subscribers[EventTodoCreated] = append(bus.subscribers[EventTodoCreated], func(v any) {
		payload, ok := v.(TodoCreatedPayload)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventTodoCreated)
}

// PublishTodoDismissed publishes a todo.dismissed event.
func (bus *EventBus) PublishTodoDismissed(payload TodoDismissedPayload) {
	select {
	case bus.ch <- envelope{event: EventTodoDismissed, payload: payload}:
		bus.runOnPublish(EventTodoDismissed, payload)
	default:
		bus.runOnDrop(EventTodoDismissed, payload)
	}
}

// SubscribeTodoDismissed registers a handler for todo.dismissed events.
func (bus *EventBus) SubscribeTodoDismissed(fn func(TodoDismissedPayload)) {
	bus.mu.Lock()
	bus.subscribers[EventTodoDismissed] = append(bus.subscribers[EventTodoDismissed], func(v any) {
		payload, ok := v.(TodoDismissedPayload)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventTodoDismissed)
}

// PublishTuiStarted publishes a tui.started event.
func (bus *EventBus) PublishTuiStarted(payload TUIStartedPayload) {
	select {
	case bus.ch <- envelope{event: EventTuiStarted, payload: payload}:
		bus.runOnPublish(EventTuiStarted, payload)
	default:
		bus.runOnDrop(EventTuiStarted, payload)
	}
}

// SubscribeTuiStarted registers a handler for tui.started events.
func (bus *EventBus) SubscribeTuiStarted(fn func(TUIStartedPayload)) {
	bus.mu.Lock()
	bus.subscribers[EventTuiStarted] = append(bus.subscribers[EventTuiStarted], func(v any) {
		payload, ok := v.(TUIStartedPayload)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventTuiStarted)
}

// PublishTuiStopped publishes a tui.stopped event.
func (bus *EventBus) PublishTuiStopped(payload TUIStoppedPayload) {
	select {
	case bus.ch <- envelope{event: EventTuiStopped, payload: payload}:
		bus.runOnPublish(EventTuiStopped, payload)
	default:
		bus.runOnDrop(EventTuiStopped, payload)
	}
}

// SubscribeTuiStopped registers a handler for tui.stopped events.
func (bus *EventBus) SubscribeTuiStopped(fn func(TUIStoppedPayload)) {
	bus.mu.Lock()
	bus.subscribers[EventTuiStopped] = append(bus.subscribers[EventTuiStopped], func(v any) {
		payload, ok := v.(TUIStoppedPayload)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventTuiStopped)
}

// OnPublish registers a hook that fires after an event is successfully enqueued.
func (bus *EventBus) OnPublish(fn func(Event, any)) {
	bus.hookMu.Lock()
	bus.onPublish = append(bus.onPublish, fn)
	bus.hookMu.Unlock()
}

// OnDrop registers a hook that fires when an event is dropped due to a full buffer.
func (bus *EventBus) OnDrop(fn func(Event, any)) {
	bus.hookMu.Lock()
	bus.onDrop = append(bus.onDrop, fn)
	bus.hookMu.Unlock()
}

// OnSubscribe registers a hook that fires after a subscriber is registered.
func (bus *EventBus) OnSubscribe(fn func(Event)) {
	bus.hookMu.Lock()
	bus.onSubscribe = append(bus.onSubscribe, fn)
	bus.hookMu.Unlock()
}

// OnPanic registers a hook that fires when a subscriber panics.
func (bus *EventBus) OnPanic(fn func(Event, any, any)) {
	bus.hookMu.Lock()
	bus.onPanic = append(bus.onPanic, fn)
	bus.hookMu.Unlock()
}

func (bus *EventBus) runOnPublish(event Event, payload any) {
	bus.hookMu.RLock()
	hooks := make([]func(Event, any), len(bus.onPublish))
	copy(hooks, bus.onPublish)
	bus.hookMu.RUnlock()
	for _, fn := range hooks {
		fn(event, payload)
	}
}

func (bus *EventBus) runOnDrop(event Event, payload any) {
	bus.hookMu.RLock()
	hooks := make([]func(Event, any), len(bus.onDrop))
	copy(hooks, bus.onDrop)
	bus.hookMu.RUnlock()
	for _, fn := range hooks {
		fn(event, payload)
	}
}

func (bus *EventBus) runOnSubscribe(event Event) {
	bus.hookMu.RLock()
	hooks := make([]func(Event), len(bus.onSubscribe))
	copy(hooks, bus.onSubscribe)
	bus.hookMu.RUnlock()
	for _, fn := range hooks {
		fn(event)
	}
}

func (bus *EventBus) runOnPanic(event Event, payload any, recovered any) {
	bus.hookMu.RLock()
	hooks := make([]func(Event, any, any), len(bus.onPanic))
	copy(hooks, bus.onPanic)
	bus.hookMu.RUnlock()
	for _, fn := range hooks {
		func() {
			defer func() { recover() }()
			fn(event, payload, recovered)
		}()
	}
}

// Reference the source variable to suppress unused-variable lint.
var _ = Events
